---
title: "植生被度階級データの状態空間モデリング"
author: "伊東宏樹"
date: '2021-03-21'
output:
  beamer_presentation:
    latex_engine: lualatex
    theme: metropolis
    keep_tex: true
    slide_level: 2
    includes:
      in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(extraDistr)
library(ggplot2)
library(ggthemes)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
library(posterior)
library(bayesplot)
```

## 目次

\tableofcontents[hideallsubsections]


# 状態空間モデル

## 時系列データ

```{r timeseries, fig.width=10, fig.height=5, out.height="5cm"}
set.seed(123)
N <- 100
Nt <- 20
x <- 1:Nt
y <- matrix(0, ncol = N, nrow = Nt)
p <- rep(0, N)
for (t in 2:Nt)
  y[t, ] <- y[t - 1, ] + rnorm(N, 0, 0.1)
for (n in 1:N)
  p[n] <- summary(lm(y[, n] ~ x))$coefficient["x", "Pr(>|t|)"]
col <- ifelse(p < 0.05, "red", "black")
df <- data.frame(Time = rep(1:Nt, N),
                 Y = c(y),
                 group = factor(rep(1:N, each = Nt)),
                 colour = rep(col, each = N))
ggplot(df) +
  geom_line(aes(x = Time, y = Y, group = group),
            colour = df$colour, alpha = 0.67) +
  theme_classic(base_family = "Helvetica", base_size = 18)
```

単純に時間を説明変数にして回帰すると、ランダムウォークでも多くの場合「ゆーい」になる。

## 状態空間モデル


\begin{center}
\includegraphics[width=9cm]{ssm.pdf}
\end{center}

- 状態方程式 $\symbf{\theta}_t = f(\symbf{\theta}_{t-1}, \symbf{w}_t)$
- 観測方程式 $y_t = g(\symbf{\theta}_t, v_t)$



# 植生被度階級データ

## 被度階級

- 0 < r < + < 1 < 2 < 3 < 4 < 5 など
- 順序尺度データ


## 被度階級

ここでは以下のようにする。

- 0--0.01 -> 1
- 0.01--0.1 -> 2
- 0.1--0.25 -> 3
- 0.25--0.5 -> 4
- 0.5--0.75 -> 5
- 0.75--1 -> 6

## ベータ分布

$$
y \sim \symup{Beta}(\alpha, \beta)
$$
平均$\mu$を使ったパラメータ化

$$
y \sim \symup{Beta}\left(\frac{\mu}{\delta}-\mu,\frac{(1-\mu)(1-\delta)}{\delta}\right)
$$
$\delta$はもともと、pin-point法による被度測定における方形区内の分布相関 (Damgaard 2012) 

しかし、被度測定における不確実性とも解釈可能。

## ベータ分布($\mu$=0.5のとき) {#beta_distribution1}

```{r plot_beta_distribution, echo=FALSE, warning=FALSE}
p <- 0.5
delta = c(0.001, 0.01, 0.1, 0.2, 0.4)
a <- p / delta - p
b <- (1 - p) * (1 - delta) / delta
x <- rep(seq(0.001, 1 - 0.001, length = 300), length(delta))
y <- matrix(0, ncol = length(delta), nrow = length(x))
for (d in seq_along(delta))
  y[, d] <- (sapply(seq_along(x), function(i) dbeta(x[i], a[d], b[d])))
df <- data.frame(Cover = x,
                 Density = c(y),
                 delta = factor(rep(delta, each = length(x))))
colors <- colorblind_pal()(8)[c(7, 6, 3, 2, 4)]
ggplot(df, aes(x = Cover, y = Density, color = delta)) +
  geom_line(size = 2, alpha = 0.9) +
  scale_color_manual(values = colors) +
#  annotate("text", x = 0, y = 24, hjust = 0,
#           label = "mu=0.6", color = "black") +
  annotate("text", x = 0.53, y = 20, hjust = 0, size = 6,
           label = bquote(delta == .(delta[1])), color = colors[1]) +
  annotate("text", x = 0.55, y = 6.5, hjust = 0, size = 6,
           label = bquote(delta == .(delta[2])), color = colors[2]) +
  annotate("text", x = 0.625, y = 3.2, hjust = 0, size = 6,
           label = bquote(delta == .(delta[3])), color = colors[3]) +
  annotate("text", x = 0.75, y = 2.35, hjust = 0, size = 6,
           label = bquote(delta == .(delta[4])), color = colors[4]) +
  annotate("text", x = 1, y = 4, hjust = 1, size = 6,
           label = bquote(delta == .(delta[5])), color = colors[5]) +
  theme_gray(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "none")
```

## ベータ分布($\mu$=0.05のとき) {#beta_distribution2}

```{r plot_beta_distribution2, echo=FALSE, warning=FALSE}
p <- 0.05
delta = c(0.001, 0.01, 0.1, 0.2, 0.4)
a <- p / delta - p
b <- (1 - p) * (1 - delta) / delta
x <- rep(seq(1e-3, 1 - 1e-3, length = 300), length(delta))
y <- matrix(0, ncol = length(delta), nrow = length(x))
for (d in seq_along(delta))
  y[, d] <- (sapply(seq_along(x), function(i) dbeta(x[i], a[d], b[d])))
df <- data.frame(Cover = x,
                 Density = c(y),
                 delta = factor(rep(delta, each = length(x))))
colors <- colorblind_pal()(8)[c(7, 6, 3, 2, 4)]
ggplot(df, aes(x = Cover, y = Density, color = delta)) +
  geom_line(size = 2, alpha = 0.9) +
  scale_color_manual(values = colors) +
  annotate("text", x = 0.075, y = 50, hjust = 0, size = 6,
           label = bquote(delta == .(delta[1])), color = colors[1]) +
  annotate("text", x = 0.09, y = 18, hjust = 0, size = 6,
           label = bquote(delta == .(delta[2])), color = colors[2]) +
  annotate("text", x = 0.11, y = 7.5, hjust = 0, size = 6,
           label = bquote(delta == .(delta[3])), color = colors[3]) +
  annotate("text", x = 0.25, y = 3, hjust = 0, size = 6,
           label = bquote(delta == .(delta[4])), color = colors[4]) +
  annotate("text", x = 0.5, y = 3, hjust = 0, size = 6,
           label = bquote(delta == .(delta[5])), color = colors[5]) +
  theme_gray(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "none")
```

## 被度階級 {#cover_class}

今回は以下のように定義する。

1: 0–0.01 (0を含む), 2: 0.01–0.1, 3: 0.1–0.25, 4: 0.25–0.5, 5: 0.5–0.75, 6: 0.75–1

$\delta$を変化させたとき、平均被度に対して、各被度階級が選ばれる確率を図示する。

<!-- Function definition -->

```{r gen_sim_data, include=FALSE}
cover_prob <- function(cover, cut_points, a, b) {
  n <- length(cut_points)
  pr <- rep(0, n + 1)
  pr[1] <- pbeta(cut_points[1], a, b)
  for (k in 2:n)
    pr[k] <- pbeta(cut_points[k], a, b) -
             pbeta(cut_points[k - 1], a, b)
  pr[n + 1] <- 1 - pbeta(cut_points[n], a, b)
  return(pr)
}

sim_cover_prob <- function(delta = c(0.001, 0.01, 0.05, 0.1),
                           cut_points = c(0.01, 0.1, 0.25, 0.5, 0.75)) {
  # delta: intra-quadrat correlation in Damgaard (2014)
  #        also can be regarded as uncertainty in classification
  # cut_points : cut points of the cover classes
  n <- length(cut_points)
  nk <- length(cut_points)
  q <- seq(0.0001, 1 - 0.0001, length = 300)
  p <- sapply(delta, function(d) {
    a <- q / d - q
    b <- (1 - q) * (1 - d) / d
    pr <- sapply(seq_along(q),
                 function(i) cover_prob(q[i], cut_points, a[i], b[i]))
  })
  df <- data.frame(delta = rep(paste0("delta=", delta), each = length(q) * (nk + 1)),
                   Cover = rep(rep(q, each = nk + 1), length(delta)),
                   Probability = c(p),
                   Class = factor(rep(rep(1:(nk + 1), length(q)), length(delta))))
  plt <- ggplot(df) +
    geom_vline(xintercept = cut_points, color = "red", size = 0.33, linetype = 2) +
    geom_line(aes(x = Cover, y = Probability, color = Class), size = 1.2) +
    labs(x = "Mean cover", y = "Probability") +
    scale_color_manual(values = colorblind_pal()(8)[c(1, 2, 3, 4, 6, 7)]) +
    facet_wrap(~delta) +
    theme_bw(base_family = "Helvetica", base_size = 24)
  print(plt)
}
```

## $\delta$=0.001

```{r delta_0.001, echo=FALSE}
sim_cover_prob(delta = 0.001)
```

## $\delta$=0.01

```{r delta_0.01, echo=FALSE}
sim_cover_prob(delta = 0.01)
```

## $\delta$=0.05

```{r delta_0.05, echo=FALSE}
sim_cover_prob(delta = 0.05)
```

## $\delta$=0.1

```{r delta_0.1, echo=FALSE}
sim_cover_prob(delta = 0.1)
```

## $\delta$=0.2

```{r delta_0.2, echo=FALSE}
sim_cover_prob(delta = 0.2)
```

## $\delta$=0.4

```{r delta_0.4, echo=FALSE}
sim_cover_prob(delta = 0.4)
```

## 模擬データ {#simdata1}

```{r sim1_datagen, include=FALSE}
cover_class <- function(q, delta = 0.1, N = 1,
                        cp = c(0.01, 0.1, 0.25, 0.5, 0.75)) {
  nk <- length(cp)
  pr <- rep(0, nk + 1)
  a <- q / delta - q
  b <- (1 - q) * (1 - delta) / delta
  pr[1] <- pbeta(cp[1], a, b)
  for (k in 2:nk)
    pr[k] <- pbeta(cp[k], a, b) - pbeta(cp[k - 1], a, b)
  pr[nk + 1] <- 1 - pbeta(cp[nk], a, b)
  rcat(N, pr)
}
N <- 10
k <- c(0.01, 0.1, 0.25, 0.5, 0.75)
p <- 0.6
delta <- 0.05
set.seed(1234)
y <- cover_class(p, delta, N)
```

- 被度 = 0.6
- $\delta$ = 0.05 とする。
- 10回測定する($N = 10$)。

生成されたデータ

```{r print_sim1, echo=FALSE}
print(y)
```

## モデルへのあてはめ {#fit_1}

```{r sim1_fit, include=FALSE}
results_file <- "fit_sim1.RData"
if (file.exists(results_file)) {
  load(results_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N = N,
               Y = y,
               CP = k)
  model <- cmdstan_model("cover.stan")
  fit1 <- model$sample(data = data,
                       chains = 4, parallel_chains = 4,
                       iter_sampling = 1000, iter_warmup = 1000)
  save(fit1, file = results_file)
}
```

## 事後分布の要約 {#summary_1}

```{r sim1_summary, echo=FALSE}
fit1$summary(variables = c("mu", "delta"))
```

## Zero-inflation


## 測定誤差



## モデリング

ベータ分布

## Stanによる実装



# 植生被度階級データの状態空間モデリング

## 模擬データ



# まとめ






