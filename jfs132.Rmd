---
title: "植生被度階級データの状態空間モデリング"
author: "伊東宏樹"
date: '2021-03-21'
output:
  beamer_presentation:
    latex_engine: lualatex
    theme: metropolis
    keep_tex: true
    slide_level: 2
    includes:
      in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(extraDistr)
library(ggplot2)
library(ggthemes)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
library(posterior)
library(bayesplot)
```

## 本日の内容

\tableofcontents[hideallsubsections]


## 本日のコード

本日のコードは以下の場所にあります。

https://github.com/ito4303/jfs132


# 状態空間モデル

## 時系列データ

```{r timeseries, fig.width=10, fig.height=5, out.height="5cm"}
set.seed(123)
N <- 100
Nt <- 20
x <- 1:Nt
y <- matrix(0, ncol = N, nrow = Nt)
p <- rep(0, N)
for (t in 2:Nt)
  y[t, ] <- y[t - 1, ] + rnorm(N, 0, 0.1)
for (n in 1:N)
  p[n] <- summary(lm(y[, n] ~ x))$coefficient["x", "Pr(>|t|)"]
col <- ifelse(p < 0.05, "red", "black")
df <- data.frame(Time = rep(1:Nt, N),
                 Y = c(y),
                 group = factor(rep(1:N, each = Nt)),
                 colour = rep(col, each = N))
ggplot(df) +
  geom_line(aes(x = Time, y = Y, group = group),
            colour = df$colour, alpha = 0.67) +
  theme_classic(base_family = "Helvetica", base_size = 18) +
  theme(panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```

単純に時間を説明変数にして線形回帰すると、ランダムウォークでも多くの場合「ゆーい」になる。

## 時系列分析

\begin{spacing}{1.5}
物理的に時間の関数になることがわかっている場合などは別として、 \\
{\Large 時系列データを正しく解析するには\textbf{時系列分析}が必要になる。}
\end{spacing}

\begin{spacing}{1.5}
本講演では、\textbf{状態空間モデル}による時系列分析をあつかう。
\end{spacing}

## 状態空間モデル


\begin{center}
\includegraphics[width=9cm]{ssm.pdf}
\end{center}



- 潜在状態の時間変化と、観測過程を分離する。
    - 状態方程式（システムモデル） $\symbf{\theta}_t = f(\symbf{\theta}_{t-1}, \symbf{w}_t)$
    - 観測方程式（観測モデル） $y_t = g(\symbf{\theta}_t, v_t)$



# 植生被度階級データ

## 被度階級データ

- 0〜1の連続値を階級データとして扱う。
    - 0 < r < + < 1 < 2 < 3 < 4 < 5 など
- 順序尺度データなので、そのまま数値として扱えない。

<!--
## この講演での被度階級

この講演は、以下の定義を用いる
（単純化のため、0は最小の階級に含める）。

- 0--0.01 $\rightarrow$ 1
- 0.01--0.1 $\rightarrow$ 2
- 0.1--0.25 $\rightarrow$ 3
- 0.25--0.5 $\rightarrow$ 4
- 0.5--0.75 $\rightarrow$ 5
- 0.75--1 $\rightarrow$ 6
-->

## ベータ分布

もともとの被度は0〜1の連続値なので、ベータ分布でモデル化することが多い。
被度の値は、ベータ分布から確率的に抽出されるとする。

$$
y \sim \symup{Beta}(\alpha, \beta)
$$
平均$\mu$を使ったパラメータ化

$$
y \sim \symup{Beta}\left(\frac{\mu}{\delta}-\mu,\frac{(1-\mu)(1-\delta)}{\delta}\right)
$$

被度階級のモデリングでは、$\delta$はpin-point法による被度測定における方形区内の分布相関 (Damgaard 2012) 。

しかし、被度測定における不確実性とも解釈可能（ただし明示的な観測誤差ではない）。

## ベータ分布($\mu$=0.5のとき) {#beta_distribution1}

```{r plot_beta_distribution, echo=FALSE, warning=FALSE}
p <- 0.5
delta = c(0.001, 0.01, 0.1, 0.2, 0.4)
a <- p / delta - p
b <- (1 - p) * (1 - delta) / delta
x <- rep(seq(0.001, 1 - 0.001, length = 300), length(delta))
y <- matrix(0, ncol = length(delta), nrow = length(x))
for (d in seq_along(delta))
  y[, d] <- (sapply(seq_along(x), function(i) dbeta(x[i], a[d], b[d])))
df <- data.frame(Cover = x,
                 Density = c(y),
                 delta = factor(rep(delta, each = length(x))))
colors <- colorblind_pal()(8)[c(7, 6, 3, 2, 4)]
ggplot(df, aes(x = Cover, y = Density, color = delta)) +
  geom_line(size = 2, alpha = 0.9) +
  scale_color_manual(values = colors) +
#  annotate("text", x = 0, y = 24, hjust = 0,
#           label = "mu=0.6", color = "black") +
  annotate("text", x = 0.53, y = 20, hjust = 0, size = 6,
           label = bquote(delta == .(delta[1])), color = colors[1]) +
  annotate("text", x = 0.55, y = 6.5, hjust = 0, size = 6,
           label = bquote(delta == .(delta[2])), color = colors[2]) +
  annotate("text", x = 0.625, y = 3.2, hjust = 0, size = 6,
           label = bquote(delta == .(delta[3])), color = colors[3]) +
  annotate("text", x = 0.75, y = 2.35, hjust = 0, size = 6,
           label = bquote(delta == .(delta[4])), color = colors[4]) +
  annotate("text", x = 1, y = 4, hjust = 1, size = 6,
           label = bquote(delta == .(delta[5])), color = colors[5]) +
  theme_bw(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```

## ベータ分布($\mu$=0.05のとき) {#beta_distribution2}

```{r plot_beta_distribution2, echo=FALSE, warning=FALSE}
p <- 0.05
delta = c(0.001, 0.01, 0.1, 0.2, 0.4)
a <- p / delta - p
b <- (1 - p) * (1 - delta) / delta
x <- rep(seq(1e-3, 1 - 1e-3, length = 300), length(delta))
y <- matrix(0, ncol = length(delta), nrow = length(x))
for (d in seq_along(delta))
  y[, d] <- (sapply(seq_along(x), function(i) dbeta(x[i], a[d], b[d])))
df <- data.frame(Cover = x,
                 Density = c(y),
                 delta = factor(rep(delta, each = length(x))))
colors <- colorblind_pal()(8)[c(7, 6, 3, 2, 4)]
ggplot(df, aes(x = Cover, y = Density, color = delta)) +
  geom_line(size = 2, alpha = 0.9) +
  scale_color_manual(values = colors) +
  annotate("text", x = 0.075, y = 50, hjust = 0, size = 6,
           label = bquote(delta == .(delta[1])), color = colors[1]) +
  annotate("text", x = 0.09, y = 18, hjust = 0, size = 6,
           label = bquote(delta == .(delta[2])), color = colors[2]) +
  annotate("text", x = 0.11, y = 7.5, hjust = 0, size = 6,
           label = bquote(delta == .(delta[3])), color = colors[3]) +
  annotate("text", x = 0.25, y = 3, hjust = 0, size = 6,
           label = bquote(delta == .(delta[4])), color = colors[4]) +
  annotate("text", x = 0.5, y = 3, hjust = 0, size = 6,
           label = bquote(delta == .(delta[5])), color = colors[5]) +
  theme_bw(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```

## 被度階級 {#cover_class}

今回は以下のように定義する。

1: 0–0.01 (0を含む), 2: 0.01–0.1, 3: 0.1–0.25,

4: 0.25–0.5, 5: 0.5–0.75, 6: 0.75–1

$\delta$を変化させたとき、平均被度に対して、各被度階級が選ばれる確率を図示する。

<!-- Function definition -->

```{r gen_sim_data, include=FALSE}
cover_prob <- function(cut_points, a, b) {
  n <- length(cut_points)
  pr <- rep(0, n + 1)
  pr[1] <- pbeta(cut_points[1], a, b)
  for (k in 2:n)
    pr[k] <- pbeta(cut_points[k], a, b) -
             pbeta(cut_points[k - 1], a, b)
  pr[n + 1] <- 1 - pbeta(cut_points[n], a, b)
  return(pr)
}

sim_cover_prob <- function(delta = c(0.001, 0.01, 0.05, 0.1),
                           cut_points = c(0.01, 0.1, 0.25, 0.5, 0.75)) {
  # delta: intra-quadrat correlation in Damgaard (2014)
  #        also can be regarded as uncertainty in classification
  # cut_points : cut points of the cover classes
  n <- length(cut_points)
  nk <- length(cut_points)
  q <- seq(0.0001, 1 - 0.0001, length = 300)
  p <- sapply(delta, function(d) {
    a <- q / d - q
    b <- (1 - q) * (1 - d) / d
    pr <- sapply(seq_along(q),
                 function(i) cover_prob(cut_points, a[i], b[i]))
  })
  df <- data.frame(delta = rep(paste0("delta=", delta), each = length(q) * (nk + 1)),
                   Cover = rep(rep(q, each = nk + 1), length(delta)),
                   Probability = c(p),
                   Class = factor(rep(rep(1:(nk + 1), length(q)), length(delta))))
  plt <- ggplot(df) +
    geom_vline(xintercept = cut_points, color = "red", size = 0.33, linetype = 2) +
    geom_line(aes(x = Cover, y = Probability, color = Class), size = 1.2) +
    labs(x = "Mean cover", y = "Probability") +
    scale_color_manual(values = colorblind_pal()(8)[c(1, 2, 3, 4, 6, 7)]) +
    facet_wrap(~delta) +
    theme_bw(base_family = "Helvetica", base_size = 24) +
    theme(panel.background = element_rect(fill = "transparent", color = NA),
          plot.background = element_rect(fill = "transparent", color = NA))
  print(plt)
}
```

## $\delta$=0.001

```{r delta_0.001, echo=FALSE}
sim_cover_prob(delta = 0.001)
```

## $\delta$=0.01

```{r delta_0.01, echo=FALSE}
sim_cover_prob(delta = 0.01)
```

## $\delta$=0.05

```{r delta_0.05, echo=FALSE}
sim_cover_prob(delta = 0.05)
```

## $\delta$=0.1

```{r delta_0.1, echo=FALSE}
sim_cover_prob(delta = 0.1)
```

## $\delta$=0.2

```{r delta_0.2, echo=FALSE}
sim_cover_prob(delta = 0.2)
```

## $\delta$=0.4

```{r delta_0.4, echo=FALSE}
sim_cover_prob(delta = 0.4)
```

## 観測値が得られる確率

\begin{align*}
Y_t &\sim \mathrm{Categorical}(\Pr(Y_t = i \mid \mu_t, \delta)), \; i \in {1,\dots,6} \\
\Pr(Y_t = 1 \mid \mu_t, \delta) &=  I\left(k_1, \frac{\mu_t}{\delta}-\mu_t,\frac{(1-\mu_t)(1-\delta)}{\delta}\right) \\
\Pr(Y_t = i \mid \mu_t, \delta) &= I\left(k_i,\frac{\mu_t}{\delta}-\mu_t,\frac{(1-\mu_t)(1-\delta)}{\delta}\right) \\
   & - I\left(k_{i-1},\frac{\mu_t}{\delta}-\mu_t,\frac{(1-\mu_t)(1-\delta)}{\delta}\right), \; i \in {2,\dots,5} \\
\Pr(Y_t = 6 \mid \mu_t, \delta) &= 1 - I\left(k_5,\frac{\mu_t}{\delta}-\mu_t,\frac{(1-\mu_t)(1-\delta)}{\delta}\right)
\end{align*}

$I$は正則化不完全ベータ関数, $k_i$は階級の境界値



## 模擬データ {#simdata1}

```{r sim1_datagen}
cover_class <- function(q, delta = 0.1, N = 1,
                        cp = c(0.01, 0.1, 0.25, 0.5, 0.75)) {
  nk <- length(cp)
  pr <- rep(0, nk + 1)
  a <- q / delta - q
  b <- (1 - q) * (1 - delta) / delta
  pr[1] <- pbeta(cp[1], a, b)
  for (k in 2:nk)
    pr[k] <- pbeta(cp[k], a, b) - pbeta(cp[k - 1], a, b)
  pr[nk + 1] <- 1 - pbeta(cp[nk], a, b)
  rcat(N, pr)
}
N <- 10
k <- c(0.01, 0.1, 0.25, 0.5, 0.75)
p <- 0.6
delta <- 0.05
set.seed(1234)
y <- cover_class(p, delta, N)
```

- 平均被度$\mu$ = 0.6
- $\delta$ = 0.05 とする。
- 10回測定する($N = 10$)。

生成されたデータ

```{r print_sim1, echo=FALSE}
print(y)
```

## Stanによるモデリング

与えられたベータ分布のパラメータ(a, b)に対して、
指定された被度階級が観測される確率を求める関数を定義する。

```{r, message=FALSE}
model_file <- "cover.stan"
s <- scan(model_file, what = character(), sep = "\n")
cat(s[c(5, 15:27)], sep = "\n")
```


## Stanによるモデリング

モデルブロック

```{r}
cat(s[59:67], sep = "\n")
```

## あてはめ結果

```{r sim1_fit, include=FALSE}
output_file <- "fit1.RDS"
if (file.exists(output_file) &
    file.mtime(output_file) < file.mtime(model_file) ) {
  fit1 <- readRDS(output_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N = N,
               Y = y,
               CP = k)
  model <- cmdstan_model(model_file)
  fit1 <- model$sample(data = data,
                       chains = 4, parallel_chains = 4,
                       iter_sampling = 2000, iter_warmup = 2000,
                       adapt_delta = 0.95)
  fit1$save_object(output_file)
}
```

```{r, echo=TRUE}
fit1$print(c("mu", "delta"))
```

## モデルの拡張

今回は扱わないが、以下のような拡張が可能

- 被度0を組み込む
    - Zero過剰モデル (Herpigny & Gosselin 2015)
    - 明示的な検出誤差 (Irvine et al. 2019)
- 明示的な測定誤差
    - 被度階級を誤る過程を明示的にモデル化 (Irvine et al. 2019)

# 植生被度階級データの状態空間モデリング

## 模擬データ

```{r sim2_data}
set.seed(4)
Nt <- 30
sigma <- 0.5
theta <- rep(0, Nt)
theta[1] <- log(0.005 / (1 - 0.005))
for (t in 2:Nt)
  theta[t] <- rnorm(1, theta[t - 1], sigma)
mu <- 1 / (1 + exp(-theta))

# generate class data
cover_rng <- function(cut_points, a, b) {
  n <- length(cut_points)
  pr <- rep(0, n + 1)
  pr[1] <- pbeta(cut_points[1], a, b)
  for (k in 2:n)
    pr[k] <- pbeta(cut_points[k], a, b) -
             pbeta(cut_points[k - 1], a, b)
  pr[n + 1] <- 1 - pbeta(cut_points[n], a, b)
  rcat(1, pr)
}

k = c(0.01, 0.1, 0.25, 0.5, 0.75)
delta <- 0.05
a <- mu / delta - mu
b <- (1 - mu) * (1 - delta) / delta

y <- sapply(seq_len(Nt),
            function(t)
              cover_rng(k, a[t], b[t]))
med_cover <- (c(k, 1) - c(0, k)) / 2 + c(0, k)

df <- data.frame(time = 1:Nt,
                 mu = mu,
                 Y = med_cover[y],
                 lab_mu = "True value",
                 lab_Y = "Observed (class med.)")
ggplot(df) +
  geom_line(aes(x = time, y = mu, colour = lab_mu), size = 2) +
  geom_point(aes(x = time, y = Y, colour = lab_Y), size = 3) +
  scale_colour_manual(name = "", values = c("red", "blue")) + 
  labs(x = "Time", y = "Cover") +
  theme_bw(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```

## 状態空間モデル

システムモデル

\begin{align*}
\mathrm{logit}(\mu_t) &= \theta_t \\
\theta_t &= \theta_{t-1} + \epsilon_t \\
\epsilon_t &\sim \mathrm{Normal}(0, \sigma^2)
\end{align*}


観測モデル

\begin{align*}
Y_t &\sim \mathrm{Categorical}(\Pr(Y_t = i \mid \mu_t, \delta)), \; i \in {1,\dots,6}
\end{align*}


$\delta$は不変とする。

## あてはめ結果

```{r sim2_fit, include=FALSE}
model_file <- "cover_ssm.stan"
output_file <- "fit2.RDS"
if (file.exists(output_file) &
    (file.mtime(output_file) < file.mtime(model_file))) {
  fit2 <- readRDS(output_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N_t = Nt,
               Y = y,
               CP = k)
  model <- cmdstan_model(model_file)
  fit2 <- model$sample(data = data,
                       chains = 4, parallel_chains = 4,
                       iter_sampling = 2000, iter_warmup = 2000,
                       adapt_delta = 0.95)
  fit2$save_object(output_file)
}
```


```{r, echo=TRUE}
fit2$print(c("delta", "sigma"))
```

## Posterior Predictive Check

```{r sim2_ppc}
yrep <- posterior::as_draws_matrix(fit2$draws(variables = "yrep"))
ppc_rootogram(y, yrep) +
  theme_classic(base_family = "Helvetica", base_size = 24) +
  theme(panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```


## 平均被度の平滑化分布

```{r sim2_plot}
mu_summary <- fit2$summary("mu")
df <- data.frame(time = 1:Nt, mu = mu, Y = med_cover[y],
                 mean = mu_summary[, "mean"],
                 q5 = mu_summary[, "q5"],
                 q95 = mu_summary[, "q95"],
                 lab_mu = "True value",
                 lab_Y = "Observed",
                 lab_smth = "Smoothed")
ggplot(df) +
  geom_line(aes(x = time, y = mu, colour = lab_mu), size = 2) +
  geom_point(aes(x = time, y = Y, colour = lab_Y), size = 3) +
  geom_line(aes(x = time, y = mean, colour = lab_smth), size = 1) +
  geom_ribbon(aes(x = time, ymin = q5, ymax = q95), fill = "gray",
              alpha = 0.33) +
  scale_colour_manual(name = "", values = c("red", "black", "blue")) + 
  labs(x = "Time", y = "Cover") +
  theme_bw(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```


## トレンドモデル

潜在状態$\theta$は、傾きがわずかに変化するとする（2階差分）

\begin{align*}
\mathrm{logit}(\mu_t) &= \theta_t \\
\theta_t - \theta_{t - 1} &= \theta_{t-1} - \theta_{t-2} + \epsilon_t \\
\epsilon_t &\sim \mathrm{Normal}(0, \sigma^2)
\end{align*}

```{r sim3_fit, include=FALSE}
model_file <- "cover_ssm2.stan"
output_file <- "fit3.RDS"
if (file.exists(output_file) &
    (file.mtime(output_file) < file.mtime(model_file))) {
  fit3 <- readRDS(output_file)
} else {
  data <- list(N_cls = length(k) + 1,
               N_t = Nt,
               Y = y,
               CP = k)
  model <- cmdstan_model(model_file)
  fit3 <- model$sample(data = data,
                       chains = 4, parallel_chains = 4,
                       iter_sampling = 2000, iter_warmup = 2000,
                       adapt_delta = 0.95, max_treedepth = 20)
  fit3$save_object(output_file)
}
```

## あてはめ結果

```{r sim3_summary, echo=TRUE}
fit3$print(c("delta", "sigma"))
```

## Posterior Predictive Check

```{r sim3_ppc}
yrep <- posterior::as_draws_matrix(fit3$draws(variables = "yrep"))
ppc_rootogram(y, yrep) +
  theme_classic(base_family = "Helvetica", base_size = 24) +
  theme(panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```

## 平均被度の平滑化分布

```{r sim3_plot}
mu_summary <- fit3$summary("mu")
df <- data.frame(time = 1:Nt, mu = mu, Y = med_cover[y],
                 mean = mu_summary[, "mean"],
                 q5 = mu_summary[, "q5"],
                 q95 = mu_summary[, "q95"],
                 lab_mu = "True value",
                 lab_Y = "Observed",
                 lab_smth = "Smoothed")
ggplot(df) +
  geom_line(aes(x = time, y = mu, colour = lab_mu), size = 2) +
  geom_point(aes(x = time, y = Y, colour = lab_Y), size = 3) +
  geom_line(aes(x = time, y = mean, colour = lab_smth), size = 1) +
  geom_ribbon(aes(x = time, ymin = q5, ymax = q95), fill = "gray",
              alpha = 0.33) +
  scale_colour_manual(name = "", values = c("red", "black", "blue")) + 
  labs(x = "Time", y = "Cover") +
  theme_bw(base_family = "Helvetica", base_size = 24) +
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA))
```


# まとめ

- 被度階級データも、時系列データも、単純には扱いにくい。
- しかし、適切にモデル化することで、うまく扱うことができる。




